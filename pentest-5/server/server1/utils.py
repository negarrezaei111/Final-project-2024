import os
from urllib.parse import urlparse, parse_qsl
import requests
import logging
from django.conf import settings
import pandas as pd
from .models import Scan

logger = logging.getLogger(__name__)
cached_payloads_sql = None
cached_payloads_xss = None


def validate_url(url):
    try:
        if not url or not isinstance(url, str):
            return False
        parsed_url = urlparse(url)
        return bool(parsed_url.scheme and parsed_url.netloc)
    except Exception as e:
        logger.error(f"URL validation error: {e}")
        return False


def assign_severity(vuln_type):
    severity_map = {
        'SQL Injection': 'Critical',
        'XSS': 'Medium'
    }
    return severity_map.get(vuln_type, 'Unknown')


def is_scan_stopped(url):

    scan = Scan.objects.filter(url=url).first()
    if scan:
        scan.refresh_from_db()
        if scan.is_stopping:
            print("is stopping in utils is true")
            return True
    return False


def check_sql_injection(url, use_deep_scan=False):
    print(f"URL received in check_sql_injection: {url}")

    if not url or not isinstance(url, str):
        raise ValueError("URL must be a non-empty string")

    if not validate_url(url):
        raise ValueError("Invalid URL: URL must be a valid and non-empty URL")

    scan_results = []

    if use_deep_scan:

        payloads = load_payloads_from_dataset(os.path.join(settings.BASE_DIR, 'server1','templates','dataset', 'Modified_SQL_Dataset.csv'), 'sql_injection')
    else:

        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
        ]

    parsed_url = urlparse(url)
    base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"

    for payload in payloads:
        query_params = {k: f"{v}{payload}" for k, v in dict(parse_qsl(parsed_url.query)).items()}
        try:
            if is_scan_stopped(url):
                print("Scan has been stopped. Aborting SQL Injection check.")
                break


            response = requests.get(base_url, params=query_params, timeout=5)
            print(f"Testing with payload: {payload}, Status Code: {response.status_code}")
            print(f"Response Text: {response.text[:500]}")

            if "error" in response.text.lower() or response.status_code == 500:
                scan_results.append({
                    "parameter": "URL",
                    "payload": payload,
                    "description": "Possible SQL Injection vulnerability detected",
                    "type": "SQL Injection",
                    "vuln_type": assign_severity("SQL Injection")
                })
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed with payload {payload}: {e}")
            scan_results.append({
                "parameter": "URL",
                "payload": payload,
                "description": str(e),
                "type": "SQL Injection",
                "vuln_type": assign_severity("SQL Injection")
            })

    return scan_results


def check_xss(url, use_deep_scan=False):
    print(f"URL received in check_xss: {url}")
    print("use scan mode in utils ", use_deep_scan)

    vulnerabilities = []

    if use_deep_scan:

        payloads = load_payloads_from_dataset(os.path.join(settings.BASE_DIR, 'server1','templates','dataset', 'XSS_dataset.csv'), 'xss')
    else:

        payloads = [
            '<script>alert(1)</script>',

        ]

    for payload in payloads:
        try:
            if is_scan_stopped(url):
                print("Scan has been stopped. Aborting XSS check.")
                return vulnerabilities

            response = requests.get(url, params={'q': payload}, timeout=5)
            print(f"Testing with payload: {payload}, Status Code: {response.status_code}")
            print(f"Response Text: {response.text[:500]}")

            if "error" in response.text.lower() or response.status_code == 500:
                vulnerabilities.append({
                    'payload': payload,
                    'response': 'XSS vulnerability found',
                    "description": "Possible XSS Injection vulnerability detected",
                    "type": "XSS",
                    "vuln_type": assign_severity("XSS")
                })
            else:
                print(f"No XSS detected with payload: {payload}")

        except requests.RequestException as e:
            vulnerabilities.append({
                'payload': payload,
                'description': str(e),
                "type": "XSS",
                "vuln_type": assign_severity("XSS")
            })

    return vulnerabilities


def load_payloads_from_dataset(file_path, vuln_type):
    global cached_payloads_sql, cached_payloads_xss


    if vuln_type == 'sql_injection':
        if cached_payloads_sql is None:
            try:
                cached_payloads_sql = []
                for chunk in pd.read_csv(file_path, encoding='ISO-8859-1', chunksize=10000):
                    cached_payloads_sql.extend(chunk['Query'].dropna().tolist())
            except Exception as e:
                logger.error(f"Error loading SQL injection payloads from dataset: {e}")
                return []
        return cached_payloads_sql
    elif vuln_type == 'xss':
        if cached_payloads_xss is None:
            try:
                cached_payloads_xss = []
                for chunk in pd.read_csv(file_path, encoding='ISO-8859-1', chunksize=10000):
                    cached_payloads_xss.extend(chunk['Payload'].dropna().tolist())
            except Exception as e:
                logger.error(f"Error loading XSS payloads from dataset: {e}")
                return []
        return cached_payloads_xss
    return []



