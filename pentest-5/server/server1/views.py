import logging
import os
import traceback
from urllib.parse import urlparse
import json
import pytz
from bs4 import BeautifulSoup
from django.conf import settings
from django.shortcuts import render
from django.http import HttpResponse
from django.views.decorators.http import require_POST, require_GET
from rest_framework.views import APIView
from .forms import ScanForm
from .scripts import start_scan, calculate_security_score, stop_scan_process, continue_scan_process
from .crawler import crawl
from django.utils import timezone
from reportlab.lib.pagesizes import letter
from io import BytesIO
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import Flowable
from pytz import timezone as pytz_timezone
import matplotlib
import matplotlib.pyplot as plt
from reportlab.lib.utils import ImageReader
from reportlab.platypus import Image
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .serializers import ScanSerializer
from django.db import transaction
from .models import Scan, SubScan, VulnerabilityDetail
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .tasks import stop_scan_task
from reportlab.lib.enums import TA_JUSTIFY


matplotlib.use('Agg')
logger = logging.getLogger(__name__)


@require_GET
def index(request):
    form = ScanForm()
    return render(request, 'server1/index.html', {'form': form})


class StartScanView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):

        if not request.user.is_authenticated:
            return JsonResponse({'error': 'User not authenticated'}, status=401)

        try:
            data = request.data
            action = data.get('action', 'start')
            scan_identifier = data.get('scan_identifier')
            scan_mode = data.get('scan_mode')
            print("scan mode in view", scan_mode)
            if not scan_mode:
                return JsonResponse({'error': 'Scan mode is required'}, status=400)

            form = ScanForm(data, current_user=request.user)

            if form.is_valid():
                url = form.cleaned_data['url']
                main_url = form.cleaned_data['url']

                if not isinstance(url, str) or not url.strip():
                    return JsonResponse({'error': 'Invalid URL format or empty URL'}, status=400)

                parsed_url = urlparse(url)
                if not parsed_url.scheme or not parsed_url.netloc:
                    return JsonResponse({'error': 'Invalid URL'}, status=400)

                if action == 'stop':
                    if not scan_identifier:
                        return JsonResponse({'error': 'Scan Identifier is required for stopping a scan'}, status=400)
                    stop_scan_task.delay(scan_identifier)
                    print("stop scan tasks", stop_scan_task(scan_identifier) )
                    scans = Scan.objects.filter(scan_identifier=scan_identifier, status='in_progress')
                    if scans.exists():
                        for scan in scans:
                            scan.is_stopping = True
                            scan.status = 'failed'
                            scan.save()
                        stop_scan_task.delay(scan_identifier)
                    else:
                        return JsonResponse({'error': 'Scan not found or already stopped'}, status=404)

                elif action == 'start':
                    scan, created = Scan.objects.get_or_create(
                        user=request.user,
                        url=url,
                        defaults={
                            'scan_date': timezone.now().astimezone(pytz.timezone('Asia/Tehran')),
                            'last_scan_date': timezone.now().astimezone(pytz.timezone('Asia/Tehran')),
                            'security_score': 100,
                            'scan_identifier': scan_identifier,
                            'main_url': main_url,
                            'status': 'in_progress'
                        }
                    )

                    crawled_urls = crawl(url, scan.id, scan_mode)
                    all_vulnerabilities = []
                    crawled_url_list = []

                    for crawled_url in crawled_urls:
                        print(" is stopping",scan.is_stopping)
                        scan.refresh_from_db()
                        print(" is stopping after refresh", scan.is_stopping)
                        if scan.is_stopping:
                            scan.status = 'failed'
                            scan.save()
                            return JsonResponse(
                                {'message': f'Scan with ID {scan_identifier} has been stopped successfully'},
                                status=200)
                        crawled_url_list.append(crawled_url)
                        if crawled_url == url:
                            continue
                        scan_instance = start_scan(crawled_url, request.user, scan_mode, main_url, scan_identifier)
                        vulnerabilities = json.loads(scan_instance.vulnerabilities) if scan_instance.vulnerabilities else []
                        all_vulnerabilities.extend(vulnerabilities)

                        SubScan.objects.create(
                            scan=scan,
                            crawled_url=crawled_url,
                            vulnerabilities=json.dumps(vulnerabilities)
                        )

                        scan.refresh_from_db()
                        if scan.is_stopping:
                            scan.status = 'failed'
                            scan.save()
                            stop_scan_task.delay(scan_identifier)
                    scan.vulnerabilities = json.dumps(all_vulnerabilities)
                    scan.is_vulnerable = bool(all_vulnerabilities)
                    security_score = calculate_security_score(all_vulnerabilities)
                    scan.security_score = security_score
                    scan.status = 'completed'
                    scan.save()

                    return JsonResponse({
                        'scan_id': scan.id,
                        'url': scan.url,
                        'scan_identifier': scan.scan_identifier,
                        'crawled_urls': crawled_url_list,
                        'vulnerabilities': all_vulnerabilities,
                        'security_score': security_score
                    })
                else:
                    return JsonResponse({'error': 'Invalid action'}, status=400)
            else:
                return JsonResponse({'error': 'Invalid form submission', 'details': form.errors}, status=400)
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON format'}, status=400)
        except Exception as e:
            logger.error(f"Error in StartScanView: {str(e)}")
            traceback.print_exc()
            return JsonResponse({'error': str(e)}, status=500)


class StopScanView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return JsonResponse({'error': 'User not authenticated'}, status=401)

        try:
            data = request.data
            scan_identifier = data.get('scan_identifier')

            if not scan_identifier:
                return JsonResponse({'error': 'Scan Identifier is required'}, status=400)

            scan = Scan.objects.filter(scan_identifier=scan_identifier, status='in_progress').first()

            if not scan:
                return JsonResponse({'error': 'No scan in progress found with this identifier'}, status=404)

            scan.is_stopping = True
            scan.status = 'failed'
            scan.save()

            return JsonResponse({'status': 'Scan stopped successfully'})

        except Exception as e:
            logger.error(f"Error in StopScanView: {str(e)}")
            traceback.print_exc()
            return JsonResponse({'error': str(e)}, status=500)


class ContinueScanView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return JsonResponse({'error': 'User not authenticated'}, status=401)

        try:

            data = request.data
            action = data.get('action', 'continue')
            scan_identifier = data.get('scan_identifier')
            scan_mode = data.get('scan_mode')

            if not scan_mode:
                return JsonResponse({'error': 'Scan mode is required'}, status=400)

            if not scan_identifier:
                return JsonResponse({'error': 'Scan Identifier is required'}, status=400)
            if action == 'stop':
                if not scan_identifier:
                    return JsonResponse({'error': 'Scan Identifier is required for stopping a scan'}, status=400)
                stop_scan_task.delay(scan_identifier)
                print("stop scan tasks", stop_scan_task(scan_identifier))
                scans = Scan.objects.filter(scan_identifier=scan_identifier, status='in_progress')
                if scans.exists():
                    for scan in scans:
                        scan.is_stopping = True
                        scan.status = 'failed'
                        scan.save()
                    return JsonResponse(
                        {'message': f'Scan with ID {scan_identifier} has been stopped successfully'}, status=200)
                else:
                    return JsonResponse({'error': 'Scan not found or already stopped'}, status=404)

            elif action == 'continue':
                print("action", action)

                scans = Scan.objects.filter(scan_identifier=scan_identifier, status='failed')
                if not scans.exists():
                    return JsonResponse({'error': 'No failed scans found for this identifier'}, status=404)


                for scan in scans:
                    scan.refresh_from_db()


                    success = continue_scan_process(scan_identifier, scan_mode)

                    if success:
                        scan.status = 'completed'
                        scan.is_stopping = False
                        scan.save()
                        return JsonResponse({
                            'scan_identifier': scan_identifier,
                        })
                    if scan.is_stopping:
                        return JsonResponse({'message': 'Scan has been stopped before continuing.'}, status=200)
                    else:
                        return JsonResponse({'error': 'Failed to continue scan'}, status=500)

        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON format'}, status=400)
        except Exception as e:
            logger.error(f"Error in ContinueScanView: {str(e)}")
            return JsonResponse({'error': str(e)}, status=500)


class FailAllScansView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return JsonResponse({'error': 'User not authenticated'}, status=401)

        try:
            data = request.data
            scan_identifier = data.get('scan_identifier')

            if not scan_identifier:
                return JsonResponse({'error': 'Scan Identifier is required'}, status=400)


            scans = Scan.objects.filter(scan_identifier=scan_identifier)

            if not scans.exists():
                return JsonResponse({'error': 'No scans found with this identifier'}, status=404)

            for scan in scans:
                scan.status = 'failed'
                scan.is_stopping = False
                scan.save()

            return JsonResponse({'status': 'All scans failed successfully'})

        except Exception as e:
            logger.error(f"Error in FailAllScansView: {str(e)}")
            traceback.print_exc()
            return JsonResponse({'error': str(e)}, status=500)


def extract_text_from_html(html_content):
    soup = BeautifulSoup(html_content, 'html.parser')
    text = soup.get_text(separator='\n')
    return text.strip()


def clean_html(html_content):
    soup = BeautifulSoup(html_content, 'html.parser')

    for img in soup.find_all('img'):
        if img.has_attr('onerror'):
            del img['onerror']

        if not img.has_attr('src') or img['src'] == 'x':
            img.decompose()

    return str(soup)


def generate_score_chart(security_score):
    if security_score >= 80:
        color = 'green'
    elif 60 <= security_score < 80:
        color = 'yellow'
    elif 40 <= security_score < 60:
        color = 'orange'
    elif 20 <= security_score < 40:
        color = 'red'
    else:
        color = 'black'

    fig, ax = plt.subplots(figsize=(3, 3), dpi=100)
    ax.pie([security_score, 100 - security_score], labels=[f'Score: {security_score}', ''],
           colors=[color, 'lightgrey'], startangle=90, counterclock=False, wedgeprops={'width': 0.3, 'edgecolor': 'none'})
    ax.axis('equal')

    buffer = BytesIO()
    plt.savefig(buffer, format='png', bbox_inches='tight', pad_inches=0)
    plt.close(fig)
    buffer.seek(0)

    return Image(buffer, width=3*inch, height=3*inch)


def get_icon_color(vuln_type):
    color_map = {
        'Critical': os.path.join(settings.BASE_DIR, 'server1','templates','image', 'red.png'),
        'Medium': os.path.join(settings.BASE_DIR, 'server1','templates','image', 'orange.png'),
    }
    return color_map.get(vuln_type, os.path.join(settings.BASE_DIR, 'templates', 'image', 'black.png'))


def get_icon_for_vuln_type(vuln_type):
    icon_path = get_icon_color(vuln_type)
    return icon_path


def draw_border(canvas, doc):
    canvas.saveState()
    canvas.setStrokeColor(colors.black)
    canvas.setLineWidth(2)

    canvas.rect(0.5 * inch, 0.5 * inch, 7.5 * inch, 10 * inch)
    canvas.restoreState()


@require_GET
def download_report(request, scan_id):
    try:
        scan = Scan.objects.get(id=scan_id)
        subscans = SubScan.objects.filter(scan=scan)
        vulnerability_details = VulnerabilityDetail.objects.filter(sub_scan__in=subscans)
        for detail in vulnerability_details:
            print(f"Vuln Type: {detail.vuln_type}, ID: {detail.id}")

        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)


        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(name='Title', fontSize=16, alignment=1, spaceAfter=12,textColor=colors.HexColor('#0BBF64'))
        heading_style = ParagraphStyle(name='Heading', fontSize=14, spaceAfter=12, textColor=colors.HexColor('#0BBF64'))
        normal_style = ParagraphStyle(name='Normal', fontSize=14, spaceAfter=6, leading=30,alignment=TA_JUSTIFY)
        elements = []

        scan_time = scan.scan_date.astimezone(pytz.timezone('Asia/Tehran'))

        img_path = os.path.join(settings.BASE_DIR,'server1', 'templates', 'image', 'firstParagraph.jpg')
        if os.path.exists(img_path):
            img = Image(img_path, width=6 * inch, height=3 * inch)
            elements.append(img)
        else:
            elements.append(Paragraph("Image not found", normal_style))

        elements.append(Paragraph(
            "VulneraXSQL is a powerful tool designed to crawl and scan web applications for SQL Injection and Cross-Site Scripting (XSS) vulnerabilities. The tool systematically sends crafted payloads to the application and analyzes server responses to detect potential security flaws.",
            normal_style ))
        elements.append(Spacer(1, 12))

        elements.append(Paragraph(f"Scan Report for {scan.url}", title_style))
        elements.append(Spacer(1, 50))
        elements.append(Paragraph(f"Scan Date: {scan_time}", normal_style))
        elements.append(Paragraph(f"Scan Status: {scan.status}", normal_style))
        elements.append(Paragraph(f"Security Score: {scan.security_score}", normal_style))

        elements.append(Spacer(1, 60))
        elements.append(Paragraph("Crawled URLs:", heading_style))
        elements.append(Spacer(1, 36))

        for subscan in subscans:
            elements.append(Paragraph(subscan.crawled_url, normal_style))
            elements.append(Paragraph(f"Depth: {subscan.depth}", normal_style))
            elements.append(Spacer(1, 12))

        elements.append(Paragraph("Security Score Chart:", heading_style))

        score_chart = generate_score_chart(scan.security_score)
        elements.append(score_chart)
        elements.append(Spacer(1, 50))

        for subscan in subscans:
            elements.append(Paragraph(f"URL: {subscan.crawled_url}", heading_style))
            elements.append(Spacer(1, 36))
            vulnerabilities = json.loads(subscan.vulnerabilities) if subscan.vulnerabilities else []
            for vuln in vulnerabilities:
                cleaned_payload = clean_html(vuln.get('payload', ''))
                vuln_type = vuln.get('vuln_type', 'Unknown')
                description = vuln.get('description', 'No description provided.')
                icon_path = get_icon_for_vuln_type(vuln_type)


                elements.append(
                    Paragraph(
                        f"<img src='{icon_path}' width=20 height=20 /> Vulnerability Type: {vuln_type}",
                        normal_style
                    )
                )
                elements.append(Paragraph(f"Parameter: {vuln.get('parameter', 'N/A')}", normal_style))
                elements.append(Paragraph(f"Payload: {cleaned_payload}", normal_style))
                elements.append(Paragraph(f"Server Response: {vuln.get('response', 'N/A')}", normal_style))
                elements.append(Paragraph(f"Description: {description}", normal_style))

        doc.build(elements, onFirstPage=draw_border, onLaterPages=draw_border)

        buffer.seek(0)
        response = HttpResponse(buffer, content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="scan_report_{scan_id}.pdf"'
        return response
    except Scan.DoesNotExist:
        return HttpResponse("Scan not found", status=404)
    except Exception as e:
        print(f"Exception: {traceback.format_exc()}")
        return HttpResponse(f"Error generating report: {str(e)}", status=500)


class UserScansView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        try:
            scans = Scan.objects.filter(user=request.user).order_by('-scan_date')
            scan_data = []


            grouped_scans = {}
            for scan in scans:
                if scan.scan_identifier not in grouped_scans:
                    grouped_scans[scan.scan_identifier] = []
                grouped_scans[scan.scan_identifier].append(scan)

            for scan_identifier, grouped_scan_list in grouped_scans.items():
                main_scan = None
                sub_scans = []

                for scan in grouped_scan_list:
                    if scan.url == scan.main_url:
                        main_scan = scan
                    else:
                        sub_scans.append({
                            'id': scan.id,
                            'url': scan.url,
                            'scan_date': scan.scan_date.strftime('%Y-%m-%d %H:%M:%S'),
                            'status' : scan.status,
                            'is_vulnerable': scan.is_vulnerable,
                            'security_score': scan.security_score,
                            'download_url': f'http://localhost:8000/api/download_report/{scan.id}/'
                        })

                if main_scan:
                    scan_data.append({
                        'main_scan': {
                            'id': main_scan.id,
                            'url': main_scan.url,
                            'scan_date': scan.scan_date.astimezone(pytz.timezone('Asia/Tehran')).strftime('%Y-%m-%d %H:%M:%S'),
                            'is_vulnerable': main_scan.is_vulnerable,
                            'security_score': main_scan.security_score,
                            'download_url': f'http://localhost:8000/api/download_report/{main_scan.id}/',
                            'status': main_scan.status
                        },
                        'sub_scans': sub_scans
                    })

            return JsonResponse({'scans': scan_data})
        except Exception as e:
            print(f"Error retrieving user scans: {traceback.format_exc()}")
            return JsonResponse({'error': 'Internal server error'}, status=500)


class SingleScanView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        try:

            scan_identifier = request.GET.get('scan_identifier', None)
            if not scan_identifier:
                return JsonResponse({'error': 'scan_identifier is required'}, status=400)


            scans = Scan.objects.filter(user=request.user, scan_identifier=scan_identifier).order_by('-scan_date')
            scan_data = []


            if not scans.exists():
                return JsonResponse({'scans': []}, status=200)


            main_scan = None
            sub_scans = []

            for scan in scans:
                scan_info = {
                    'id': scan.id,
                    'url': scan.url,
                    'scan_date': scan.scan_date.strftime('%Y-%m-%d %H:%M:%S'),
                    'is_vulnerable': scan.is_vulnerable,
                    'security_score': scan.security_score,
                    'download_url': f'http://localhost:8000/api/download_report/{scan.id}/',
                    'status': scan.status
                }

                if scan.url == scan.main_url:
                    main_scan = scan_info
                else:
                    sub_scans.append(scan_info)

            if main_scan:
                scan_data.append({
                    'main_scan': main_scan,
                    'sub_scans': sub_scans,
                    'scan_data': scan.scan_date.strftime('%Y-%m-%d %H:%M:%S')
                })

            return JsonResponse({'scans': scan_data})
        except Exception as e:
            print(f"Error retrieving scan results: {traceback.format_exc()}")
            return JsonResponse({'error': 'Internal server error'}, status=500)


class UniqueMainURLsView(APIView):
    def get(self, request, *args, **kwargs):
        try:
            scans = Scan.objects.filter(user=request.user).order_by('scan_identifier', '-scan_date')
            print("All Scans: ", scans)

            unique_main_urls = []

            seen_identifiers = set()

            for scan in scans:
                if scan.scan_identifier not in seen_identifiers:
                    seen_identifiers.add(scan.scan_identifier)
                    unique_main_urls.append(scan.main_url)

            print("Unique Main URLs: ", unique_main_urls)

            return Response({'main_urls': unique_main_urls})
        except Exception as e:
            print(f"Error retrieving unique main URLs: {e}")
            return Response({'error': 'Internal server error'}, status=500)